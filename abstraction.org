* Motivation
This is an attempt to better understand how the process of abstraction can be used in computational models of intelligence.  It is also an experiment in literate-style programming and questions related to literate programming will be prefaced with LP?
* Approach
One way to formulate the problem of modeling intelligence is by vieweing it as a process of inference over incomplete data influenced by previously perceived data.  As a starting point we can imagine data as being a (possibly nested) list of symbols.  An inference problem can be described as a (possibly nested) list containing variables where the variables represent an unknown part of the list that should be filled in.
* Examples
** Binary Classification
An example of a problem that can be formulated in terms of inference on lists is classification of binary data.  We can write input data as
#+name: binary_data
#+begin_src python :results value
pattern0 = [[[1], 0], [[1,1], 0], [[1,1,1,1,1], 0], [[1,1], 0]]
pattern1 = [[[1,1,0,0],1], [[1,1,1,0,0,0],1], [[1,1,1,1,0,0,0,0],1]]
#+end_src

With org-mode's literate programming support we can display this data in a nice format like so
#+begin_src python :results value :noweb yes
  <<binary_data>>
  return pattern0+pattern1
#+end_src

#+RESULTS:
| (1)               | 0 |
| (1 1)             | 0 |
| (1 1 1 1 1)       | 0 |
| (1 1)             | 0 |
| (1 1 0 0)         | 1 |
| (1 1 1 0 0 0)     | 1 |
| (1 1 1 1 0 0 0 0) | 1 |

*** First Approximation
A simple (but expected to be poor performing) algorithm for the inference problem would be to store every piece of data then when an inference problem (i.e. partial piece of data) is faced we try to match what is known to any of the pieces of data that have already been seen and then use a matching piece of data to fill in the unknowns in the inference problem.  

Even though it's not hard to think of cases where this algorithm won't work, we start with this problem to build up some of the general infrastructure for modeling inference and abstraction and make the idea of modeling intelligence as inference on lists more concrete.

**** Storing data
The first part of the algorithm is to store data.  We'll use a list as the data structure to keep things simple for now, but use a layer of abstraction to manipulate it.
#+name: memory
#+begin_src python 
  class Memory:
      memory = []
      def add(self, data):
          self.memory.append(data)
  
#+end_src
Now we test the function using the binary data from earlier
#+name: test_memory
#+begin_src python :results value :noweb yes
  <<binary_data>>
  <<memory>>
  memory = Memory()
  for data in pattern0:
      memory.add(data)
  
  return memory.memory
  
#+end_src

#+RESULTS: test_memory
| (1)         | 0 |
| (1 1)       | 0 |
| (1 1 1 1 1) | 0 |
| (1 1)       | 0 |


***** LP? Python mode in src blocks?
What is the best way to edit code in the source blocks?  By default, emacs seems to be in org-mode.
****** C-c '
http://orgmode.org/manual/Editing-source-code.html#Editing-source-code

**** Inference
Now that we have a way to hold prior data we want to be able to use that data to solve inference problems.  Let's formalize our earlier approach of inference on nested lists.
***** inference formulation
An inference problem can be described as a list with some variables that represent unknown parts of the list.  Elements of the list can be either lists, symbols, or variables.  In code the class might look like

#+name: inference_problem
#+begin_src python :results value
  class InferenceProblem:
      #variables that might appear in partial_data
      variables = []
      partial_data = []
  
      def __init__(self, initial_variables, initial_partial_data):
          self.variables = initial_variables
          self.partial_data = initial_partial_data
  
#+end_src

We could make the typing more explicit by performing checks during instantiation of the class, but we'll leave it unless this becomes an issue.

****** Binary Data Inference Problems
******* Classification
One example of an inference problem is classification of binary data.  Suppose we have some data from either pattern0 or pattern1 above as shown earlier and we want to infer the pattern it came from, we can create a problem like so
#+name: binary_data_classification_problems
#+begin_src python :results output :noweb yes
  <<inference_problem>>
  
  classify_problem0 = InferenceProblem(['v0'],[[1,1,1,1], 'v0'])  
  classify_problem1 = InferenceProblem(['v0'], [[1,1,1,0,0,0], 'v0'])

  print classify_problem0.variables
#+end_src

#+RESULTS: binary_data_classification_problems
: ['v0']

The solution for classify_problem0 being v0 is [0] and the solution for classify_problem1 being v0 is [1].  The reason the solutions are in a list is that variables may represent several missing elements in a list.  This is better illustrated in the next example.
******* Completion
Another type of problem would be to infer parts of the binary data given we know the pattern e.g.

#+name: binary_data_completion_problems
#+begin_src python :results value :noweb yes
  complete_problem0 = InferenceProblem(['v0'], [[1,1,1,'v0'], 1])
  complete_problem1 = InferenceProblem(['v0', 'v1'], [['v1', 1, 'v2'], 0])
#+end_src
The solution for the first problem intuitively is v0 is [0, 0, 0].  The second problem, complete_problem1, raises the issue that problems do not necessarily have a unique answer.  For this problem v1 and v2 could be lists of 1 of arbitrary length e.g. v0 is [1, 1, 1] and v1 is [1] or v0 is [1,1] and v1 is [1,1,1,1].  We'll take a closer look at solutions to inference problems and evaluating them in the next section.

****** Binary Data Solutions
An inference problem is a set of variables along with a list containing those variables.  The solution to inference problems are values that are assigned to those variables (bindings or an environment) and are substituted in the following way.

#+name: substitute_function
#+begin_src python :results value
  def substitute(partial_data, bindings):
      """
      replace variables in the abstraction with the matching values in the bindings
      and return the resulting list
      """
      complete_list = []
      for element in partial_data:
          replacement = swap(element, bindings)
          complete_list += replacement
      return complete_list
  
  def swap(element, bindings):
          if element in bindings.keys():
              return bindings[element]
          elif isinstance(element, list):
              return [substitute(element, bindings)]
          else:
              return [element]
  
#+end_src

We can demonstrate the substitute function on our earlier examples of inference problems like so

#+name: substitution_examples
#+begin_src python :results output :noweb yes
  <<substitute_function>>
  <<binary_data_classification_problems>>
  <<binary_data_completion_problems>>
  
  print substitute(classify_problem0.partial_data, {'v0': 1})
#+end_src

#+RESULTS: substitution_examples

#+RESULTS: subsitution_examples
TODO: debugging literate programming code?  perhaps tangle to debug?
TODO: discuss why replacing a variable with a list allows for more flexibility in specifying problems
